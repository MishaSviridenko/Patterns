## Patterns
Andersen_Task2_Patterns

* Creational (Порождающие)
1. Abstract Factory - Abstract Factory - объединяет группу обычных фабрик (FactoryMethod).
                       Смысл в том, что есть пары (или больше) одинаковых классов
                       Keyboard, Mouse, Touchpad. Каждая пара классов имеет английскую
                       и русскую реализации. Т.е. обычная Фабрика №1 реализует русскую
                       версию классов, обычная Фабрика №2 реализует английскую версию
                       классов, а Abstract Factory объединяет эти две фабрики.
2. Builder - Отделяет конструирование сложного объекта от его представления, так что
             в результате одного и того же процесса конструирования могут получаться
             разные представления.
3. Factory Method - Определяет интерфейс для создания объекта,но оставляет подклассам решение
                    о том, какой класс инстанцировать. Фабричный метод позволяет классу делегировать
                    инстанцирование подклассам.                     
4. Prototype - Должен уметь генерировать самого себя.
               в JDC предусмотрен интерфейс Clonable имеющий метод clone(). 
               Имплементация этого интерфейса и переопределение метода clone() реализует
               шаблон Prototype. В методе clone() будет просто создаваться объект класса
               реализующего интерфейс Clonable. 

5. Singleton

* Structural (Структурные)
1. Adapter - Преобразует интерфейс одного класса в интерфейс другого,
              который ожидают клиенты. Адаптер обеспечивает совместную
              работу классов с несовместимыми интерфейсами, которая без
              него была бы невозможна.
2. Bridge - Отделить абстракцию от ее реализации так, чтобы
            то и другое можно было изменять независимо.
3. Composite - Компонует объекты в древовидные структуры для представления
               иерархий часть-целое. Позволяет клиентам единообразно трактовать
               индивидуальные и составные объекты.
4. Decorator - Динамически добавляет объекту новые обязанности. Является
               гибкой альтернативой порождению подклассов с целью расширения
               функциональности.
5. Facade - Предоставляет унифицированный интерфейс вместо набора интерфейсов
            некоторой подсистемы. Фасад определяет интерфейс более высокого
            уровня, который упрощает использование подсистемы.
6. Flyweight - Использует разделение для эффективной поддержки множества мелких
              объектов.
7. Proxy - Является суррогатом другого объекта и контролирует доступ к нему.

* Behavioral (Поведенческие)
1. Chain of Responsibility - Позволяет избежать привязки отправителя запроса к его получателю,
                             давая шанс обработать запрос нескольким объектам. Связывает
                             объекты-получатели в цепочку и передает запрос вдоль этой цепочки,
                             пока его не обработают.
2. Command - Инкапсулирует запрос как объект, позволяя тем самым задавать
             параметры клиентов для обработки соответствующих запросов,
             ставить запросы в очередь или протоколировать их, а также
             поддерживать отмену операций.
3. Interpreter - Предназначен для решения повторяющихся задач, которые можно
                 описать некоторым  языком. Для этого паттерн Interpreter
                 описывает решаемую задачу в виде предложений этого языка,
                 а затем интерпретирует их. Для заданного языка определяет
                 представление его грамматики, а также интерпретатор предложений
                 этого языка.
4. Iterator - Предоставляет механизм обхода элементов составных объектов
              (коллекций) не раскрывая их внутреннего представления.
4. Mediator - Определяет объект, инкапсулирующий способ взаимодействия множества
              объектов. Посредник обеспечивает слабую связанность системы,
              избавляя объек ты от необходимости явно ссылаться друг на друга
              и позволяя тем самым незави симо изменять взаимодействия между ними.
5. Memento - Не нарушая инкапсуляции, фиксирует и выносит за пределы объекта
             его внутреннее состояние так, чтобы позднее можно было
             восстановить в нем объект.
6. Observer -пределяет зависимость типа «один ко многим» между объектами
             таким образом, что при изменении состояния одного объекта все
             зависящие от него оповещаются об этом и автоматически обновляются.
7. State - Состояние - позволяет объекту изменять свое поведение в
           зависимости от внутреннего состояния. Создается впечатление,
           что объект изменил свой класс. Паттерн State является
           объектно-ориентированной реализацией конечного автомата.
8. Strategy - Определяет семейство алгоритмов, инкапсулирует каждый из них и
              делает их взаимозаменяемыми. Стратегия позволяет изменять
              алгоритмы независимо от клиентов, которые ими пользуются.
9. Template Method - Шаблонный метод определяет основу алгоритма и позволяет подклассам
                     переопределить некоторые шаги алгоритма, не изменяя его структуру
                     в целом.
10. Visitor - Описывает операцию, выполняемую с каждым объектом из некоторой
              структуры. Паттерн посетитель позволяет определить новую операцию,
              не изменяя классы этих объектов.

